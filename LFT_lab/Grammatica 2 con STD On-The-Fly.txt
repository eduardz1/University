P   -> {statlist.next=newlabel()} SL {emitlabel(statlist.next)} eof  

SL  -> S SLP {S.next=newlabel() SLP.next=SLP.next SLP.code=S.code}{S.next:SLP.code}

SLP -> ; S SLP
SLP -> epsilon

S   -> assign E to I
S   -> print ( EL )
S   -> read ( I )
S   -> while ( B ) {B.true=newlabel() B.false=S.next S1.next=newlabel() S.code=S1.next:B.code || B.true:S1.code}
S   -> if ( B ) S SP
S   -> { SL } {SL.next=S.next S.code=SL.code}

SP  -> end
SP  -> else S end

I   -> id IP

IP  -> , id IP
IP  -> epsilon {IP.code=goto IP.next}

B   -> relop E E

E   -> + ( EL )
E   -> - E E {emit(isub)}
E   -> * ( EL )
E   -> / E E {emit(idiv)}
E   -> {emit(ldc, val)} num 
E   -> {emit(iload, id_addr)} id

EL  -> E ELP

ELP -> , E ELP
ELP -> epsilon
